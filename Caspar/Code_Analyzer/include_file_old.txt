File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\dmatrix.h
#pragma once
#include <vector>

//This implements a "dense" style matrix and limited matrix operations using std::vector

template <class T>
class dmatrix
{
	std::vector<T> mat;

public:
	size_t m;
	size_t n;

	//Constructor
	dmatrix(const size_t i, const size_t j)
	{
		m = i;
		n = j;
		
		mat.resize(m*n, 0);
	};

	dmatrix()
	{
	};

	void resize(const size_t i, const size_t j)
	{
		//clear the current matrix
		mat.clear();

		m = i;
		n = j;
		
		mat.resize(m*n, 0);
	};

	//Direct matrix access (i,j)
	__inline T & operator() (const size_t i, const size_t j) 
	{
		return mat[i*n+j];
	}

	__inline const T & operator() (const size_t i, const size_t j) const
	{
		return mat[i*n+j];
	}

	//Direct matrix access [i]
	__inline T & operator[] (const int i) 
	{
		return mat[i];
	}

	//Scalar multiplication
	dmatrix<T> & operator*= (const double s)
	{
		for(int i=0; i<m*n; i++)
		{
			mat[i] *= s;
		}
		return *this;
	}

	//Matrix multiplication
	dmatrix<T> operator* (const dmatrix<T> & M) const
	{
		if(n != M.m)
		{
			//Invalid matrix sizes for multiplication
			return dmatrix<T> (0,0);
		}
		dmatrix<T> r(m,M.n);

		for(int i=0; i<m; i++)
		{
			for(int j=0; j<M.n; j++)
			{
				for(int k=0; k<n; k++)
				{
					//could optimize to use direct indexing?
					r(i,j) += (*this)(i,k)*M(k,j);
				}
			}
		} 

		return r;
	}

	//Matrix addition
	dmatrix<T> & operator+= (const dmatrix<T> M)
	{
		if(m != M.m || n != M.n)
		{
			//Invalid matrix sizes for addition so don't do anything
			return *this;
		}

		for(int i=0; i<m*n; i++)
		{
			mat[i] += M(i);
		}
		return *this;
	}

	//Transpose
	dmatrix<T> t()
	{
		dmatrix<T> trans(n,m);
		for(int i=0; i<m; i++)
		{
			for(int j=0; j<n; j++)
			{
				trans(j,i) = (*this)(i,j);
			}
		}

		return trans;
	}

	//Matrix Determinate
	double det()
	{
		if(m != n)
		{
			return 0;
		}

		if(m == 1)
		{
			return mat[0];
		}

		//We will use Laplace's formula for the determinate
		double d = 0;
		for(int j=0; j<n; j++)
		{
			//Create the 'Minor' matrix
			dmatrix M(m-1, n-1);
			for(int r=1; r<m; r++)
			{
				for(int c=0; c<n; c++)
				{
					if(c < j)
					{
						M(r-1,c) = (*this)(r,c);
					} else if (c > j)
					{
						M(r-1,c-1) = (*this)(r,c);
					}
				}
			}
			
			d += pow(-1.0,j) * (*this)(0,j) * M.det();
		}
		return d;
	}

};


File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\element.h
#pragma once
#include <string>
#include <vector>

#include "node.h"

struct element
{
	enum element_types
	{
		C3D4
	};

	element_types type;
	std::vector<size_t> nodes;
};


File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\elementset.h
#pragma once
#include <vector>

#include "material.h"

class elementset : public std::vector<size_t>
{
public:
	material_type material;
};


File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\element_C3D4.h
#pragma once
#include <vector>

#include "dmatrix.h"
#include "node.h"
#include "material.h"
#include "face.h"

class C3D4
{
private:
	std::vector<const node*> nodes;
	material_type material;

	dmatrix<double> Be();
	dmatrix<double> De();
	dmatrix<double> Ke();
	void calc_detJ();
	void calc_V();
	double x(const int n);
	double y(const int n);
	double z(const int n);

	double V;
	double detJ;

public:
	C3D4(const std::vector<const node*> &Nodes, material_type mat);
	void calc(dmatrix<double> &Kele, std::vector<double>& node_mass);
	std::vector<int> C3D4::ldof2gdof();
	std::vector<face> getfaces();
};


File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\face.h
#pragma once
#include <vector>

#include "dmatrix.h"
#include "node.h"

//Face definition
class face
{
	double triarea(const int n1, const int n2, const int n3) const;

	public:
		std::vector<const node *> nodes;
		
		void push_back(const node * n);
		bool operator<(const face & f) const;
		double area() const;
		point normal() const;
		point centroid() const;
};

File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\fem.h
#pragma once
#include <vector>
#include <map>
#include <set>
#include <string>
#include "mkl.h"
#include <gmm/gmm.h>

#include "femoptions.h"
#include "node.h"
#include "element.h"
#include "elementset.h"
#include "nodeset.h"
#include "face.h"

class fem
{
public:
	typedef std::map<size_t, point> loadmap_t;

	enum im_direction_t
	{
		NORMAL,
		ANTI_NORMAL
	};

public:
	std::vector<node> nodes;
	size_t nodecnt;
	
	int udof;	//number of unconstrainted DOF

	std::vector<element> elements;
	size_t elementcnt;

	std::map<std::string, nodeset> nodesets;
	std::map<std::string, elementset> elementsets;

	//stiffness matrix
	//need to use row matrix type to aid in INTEL CSR conversion
	//This is the matrix in which the stiffness matrix is built
	gmm::row_matrix<gmm::wsvector<double> > K_gmm;
	
	//This a the compressed storage [column] format used by the gmm solvers
	gmm::csc_matrix<double>	K_gmm_csc;

	//node mass matrix (lumped form, so a diagonal vector)
	std::vector<double> nodes_mass;

	//
	std::map<face, size_t> externalelementfaces;

	//the gap set
	nodeset* gap_nodeset;

	//faces that makeup the gap set, used for searching
	std::set<const face*> gap_face_set;

	//faces that makeup the gap set, used to sequential loading
	std::vector<const face*> gap_face_vector;

	//gap node normals
	std::vector<point> gap_node_norms;

	//used for IR
	struct
	{
		double body_mass;
		point cog;
		double scale;
	} IR;

	//which way is defined as 'positive' for the im's
	im_direction_t im_direction;

	//Intel MKL
	struct mkl_t
	{
		void* pt[64];
		_INTEGER_t maxfct;
		_INTEGER_t mnum;
		_INTEGER_t mtype;
		_INTEGER_t phase;
	
		_INTEGER_t iparm [64];
		_INTEGER_t msglvl;
		_INTEGER_t error;

		_INTEGER_t n;
		
		double * K_csr;
		_INTEGER_t * ia;
		_INTEGER_t * ja;

		_INTEGER_t * perm;	//not used

		mkl_t()
		{
			K_csr = NULL;
			ia = NULL;
			ja = NULL;
		}

		~mkl_t()
		{
			if(K_csr != NULL)
			{
				delete [] K_csr;
				K_csr = NULL;
			}
			if(ia != NULL)
			{
				delete [] ia;
				ia = NULL;
			}
			if(ja != NULL)
			{
				delete [] ja;
				ja = NULL;
			}
		}
		
	} mkl;

	//helper methods
	std::vector<const node*> nid2node(const std::vector<size_t> &nids);
	static std::vector<double> inverse_3x3(const std::vector<double> A);

public:
	//fem options
	femoptions options;
	
	//Member methods - IO
	void readoptions(std::string file);
	void loadinp();
	void writeVTK(std::string filename, const std::vector<double>& b, const std::vector<double>& x);
	void writeFacesetVTK(const std::string filename, const std::vector<const face*>& fs);
	void getim(const std::vector<double>::iterator x, std::vector<double>& im);

	//Member methods - loading
	void setupgap(std::string gap_set_name, im_direction_t direction);
	void nodeset2faceset(const nodeset& ns, std::vector<const face*>& fs);
	void load_gap_face(size_t faceid, double pressure, loadmap_t& loadmap);
	void load_set(std::string setname, double pressure, loadmap_t& loadmap);

	void loadmap2b(const loadmap_t& loadmap, std::vector<double>::iterator b);
	void loadmap2b(const loadmap_t& loadmap, std::vector<double> &b);
	
	//Member methods - helping
	void number_DOF();
	void stiffness_matrix(const bool only_triu = false);
	size_t get_gap_facecnt();
	size_t get_gap_nodecnt();
	int get_udof();

	//Solving - gmm
	void gmm_setup();
	bool gmm_solve(const loadmap_t& loadmap, std::vector<double>& b, std::vector<double>& x);

	//Solving - MKL
	void K_gmm2K_csr(bool only_triu = true);
	void mkl_phase0();
	void mkl_phase11();
	void mkl_phase22();
	void mkl_phase33(_INTEGER_t nrhs, double* b, double * x);
	void mkl_gap_ims(int startid, _INTEGER_t nrhs, std::vector<double>& b, std::vector<double> &x);
	void mkl_solve(const loadmap_t& loadmap, std::vector<double>& b, std::vector<double>& x);

};

File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\femoptions.h
#pragma once
#include <string>
#include <vector>
#include <map> 

#include "material.h"

struct femoptions
{
	struct elastic_constraint
	{
		int x;
		int y;
		int z;
	};

	//general options
	std::string pump_name;
	std::string meshfile;
	double scalefactor;
	
	//Activate Inertial Relief 
	int inrel;

	//specify the RAM ammount for Pardiso solver
	int max_ram;
	
	//The list of materials / elastic constraints
	std::vector<material_type> materials;
	std::map<std::string, size_t> elementset_material;
	std::map<std::string, elastic_constraint> elastic_constraints;

	//constructor
	femoptions()
	{
		//default maxRAM to 2000 MB
		max_ram = 2000;

		//default inertia relief to 0
		inrel = 0;

		//default scale factor to 1e-3
		scalefactor = 1e-3;

		//ensure the lists are clear
		materials.clear();
		elastic_constraints.clear();
	}

	//Clear method
	void clear()
	{
		femoptions();
	}
};


File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\influgen.h
#pragma once
#include <string>
#include <map>

#include "fem.h"


class influGen
{
public:
	enum part_type
	{
		PISTON,
		BUSHING,
		BLOCK,
		VALVEPLATE,
		SLIPPER,
		SWASHPLATE,
		NONE
	};

	enum solver_type
	{
		GMM,
		PARDISO
	};

	part_type part;
	const solver_type solver;
	fem model;
	
private:
	//these two functions are used to generate the correct file path for each interface
	std::string filename_gap(size_t id, bool is_vtk = false);
	std::string filename_gapim();
	std::string filename_set(std::string setname, bool is_vtk = false);

public:
	influGen(part_type Part, solver_type Solver);	
	void load(const std::string optionfile);
	void stiffness();
	void setup(const std::string gap_set_name);
	
	void make_SlipperSwash_mesh_files();
	void make_PistonBush_mesh_files();
	void make_BlockVP_mesh_files();
	
	void make_vizvtksets();

	void cleanup();
	void gmm_gap_im(size_t id, bool writevtk = false);
	void gmm_set_im(std::string setname, bool writevtk = false);
	void mkl_gap_ims();
	void mkl_set_im(std::string setname, bool writevtk);
	void mkl_gap_im(size_t id, bool writevtk = false);

};

File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\material.h
#pragma once
#include <string>

struct material_type
{
	std::string name;
	double E;
	double nu;
	double rho;
};


File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\node.h
#pragma once
#include <array>
#include "point.h"

struct node
{
	//the node id in the global node vector
	size_t nid;

	//XYZ location
	point coord;

	//global DOF numbering
	//assume 3 DOF / node
	std::array<int, 3> DOF;

	node()
	{
		coord = point(0,0,0);
	};

	node(const point p)
	{
		coord = p;
	};

	node(const double x,const double y, const double z)
	{
		coord = point(x,y,z);
	};

	double operator[] (const int i) 
	{
		return coord[i];
	};

	double x() const
	{
		return coord.x();
	};

	double y() const
	{
		return coord.y();
	};

	double z() const
	{
		return coord.z();
	};
};

File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\nodeset.h
#pragma once
#include <vector>

//using a vector instead of a set to maintain read order in the event
//the read order was not ascending ordered
class nodeset : public std::vector<size_t>
{
public:
	bool const_x;
	bool const_y;
	bool const_z;

	nodeset()
	{
		const_x = false;
		const_y = false;
		const_z = false;
	}
};


File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\point.h
#pragma once

struct point
{
	double coord[3];

	point(const double x, const double y, const double z)
	{
		coord[0] = x;
		coord[1] = y;
		coord[2] = z;
	};

	point()
	{
		for(int i=0; i<3; i++)
		{
			coord[i] = 0;
		}
	};

	double & operator[] (const int i) 
	{
		return coord[i];
	}

	const double & operator[] (const int i) const
	{
		return coord[i];
	}

	double x() const
	{
		return coord[0];
	};

	double y() const
	{
		return coord[1];
	}

	double z() const
	{
		return coord[2];
	}

	point operator+ (point p) const
	{
	  for(int i=0; i<3; i++)
	  {
		  p.coord[i] += coord[i];
	  }
	  return (p);
	}

	point operator* (double d) const
	{
		point p;
	  for(int i=0; i<3; i++)
	  {
		  p.coord[i] = coord[i]*d;
	  }
	  return (p);
	}

	point & operator+= (point p) 
	{
	  for(int i=0; i<3; i++)
	  {
		  coord[i] += p[i];
	  }
	  return *this;
	}

	point operator- (point p) const
	{
	  for(int i=0; i<3; i++)
	  {
		  p.coord[i] = coord[i] - p.coord[i];
	  }
	  return (p);
	}

	point & operator*= (const double s) 
	{
	  for(int i=0; i<3; i++)
	  {
		  coord[i] *= s;
	  }
	  return *this;
	}

	point & operator/= (const double s) 
	{
	  for(int i=0; i<3; i++)
	  {
		  coord[i] /= s;
	  }
	  return *this;
	}

	double norm()
	{
		double norm2 = 0;
		for(int i=0; i<3; i++)
		{
			norm2 += coord[i]*coord[i];
		}
		return pow(norm2, 0.5);
	}

	double dot(const point p) const
	{
		double d = 0;
		for(int i=0; i<3; i++)
		{
			d += coord[i]*p.coord[i];
		}
		return d;
	}

	static point cross(const point & p1, const point & p2)
	{
		point c;
		c[0] = p1.y()*p2.z()-p1.z()*p2.y();
		c[1] = p1.z()*p2.x()-p1.x()*p2.z();
		c[2] = p1.x()*p2.y()-p1.y()*p2.x();
		return c;
	}
};

File: E:/Job_1/SHS--Original/localCopy/influgen_2/src\string_functions.h
#pragma once 
#include <string>
#include <sstream>
#include <vector>

//Utility functions used for text reading
namespace string_functions
{
	std::vector<std::string> Tokenize(const std::string& str,const std::string& delimiters);
	double s2d(const std::string s);
	int s2i(const std::string s);
	std::string str2lower(std::string s);
	std::string trim(std::string s);

	template <class T> std::string n2s(const T number)
	{
		std::ostringstream oss (std::ostringstream::out);
		oss.str("");
		oss << number;
		return oss.str();
	};
}


