File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\dmatrix.h
#pragma once
#include <vector>
#include <iostream>
#include <cmath>

template <class T>
class dmatrix {
    std::vector<T> mat;

public:
    size_t m{ 0 }, n{ 0 };

    // Constructor
    explicit dmatrix(size_t i, size_t j) : m(i), n(j), mat(m* n, T{}) {}

    // Default constructor
    dmatrix() = default;

    // Resize function
    void resize(size_t i, size_t j) {
        m = i;
        n = j;
        mat.assign(m * n, T{}); // More efficient than clear + resize
    }

    // Direct matrix access (i,j)
    [[nodiscard]] inline T& operator()(size_t i, size_t j) noexcept {
        return mat[i * n + j];
    }

    [[nodiscard]] inline const T& operator()(size_t i, size_t j) const noexcept {
        return mat[i * n + j];
    }

    // Direct access operator [i]
    [[nodiscard]] inline T& operator[](size_t i) noexcept {
        return mat[i];
    }

    [[nodiscard]] inline const T& operator[](size_t i) const noexcept {
        return mat[i];
    }

    // Scalar multiplication
    dmatrix<T>& operator*=(T scalar) noexcept {
        for (auto& val : mat) {
            val *= scalar;
        }
        return *this;
    }

    // Matrix multiplication
    [[nodiscard]] dmatrix<T> operator*(const dmatrix<T>& M) const {
        if (n != M.m) {
            throw std::invalid_argument("Invalid matrix sizes for multiplication");
        }

        dmatrix<T> result(m, M.n);
        for (size_t i = 0; i < m; ++i) {
            for (size_t j = 0; j < M.n; ++j) {
                T sum{};
                for (size_t k = 0; k < n; ++k) {
                    sum += (*this)(i, k) * M(k, j);
                }
                result(i, j) = sum;
            }
        }
        return result;
    }

    // Matrix addition
    dmatrix<T>& operator+=(const dmatrix<T>& M) {
        if (m != M.m || n != M.n) {
            throw std::invalid_argument("Matrix sizes do not match for addition");
        }

        for (size_t i = 0; i < mat.size(); ++i) {
            mat[i] += M.mat[i];
        }
        return *this;
    }

    // Transpose
    [[nodiscard]] dmatrix<T> transpose() const {
        dmatrix<T> trans(n, m);
        for (size_t i = 0; i < m; ++i) {
            for (size_t j = 0; j < n; ++j) {
                trans(j, i) = (*this)(i, j);
            }
        }
        return trans;
    }

    // Matrix Determinant (Recursive)
    [[nodiscard]] T det() const {
        if (m != n) {
            throw std::invalid_argument("Matrix must be square to compute determinant");
        }

        if (m == 1) return mat[0];

        T determinant = 0;
        for (size_t j = 0; j < n; ++j) {
            dmatrix<T> minor(m - 1, n - 1);
            for (size_t r = 1; r < m; ++r) {
                size_t minorCol = 0;
                for (size_t c = 0; c < n; ++c) {
                    if (c == j) continue;
                    minor(r - 1, minorCol++) = (*this)(r, c);
                }
            }
            determinant += ((j % 2 == 0) ? 1 : -1) * (*this)(0, j) * minor.det();
        }
        return determinant;
    }
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\element.h
#pragma once
#include <string>
#include <vector>

#include "node.h"

struct Element
{
    enum class ElementType
    {
        C3D4
    };

    ElementType type{ ElementType::C3D4 };  // Default initialization
    std::vector<size_t> nodes;
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\elementset.h
#pragma once
#include <vector>

#include "material.h"

class ElementSet
{
public:
    std::vector<size_t> indices; // Instead of inheritance, use composition
    material_type material;
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\element_C3D4.h
#pragma once
#include <vector>
#include "dmatrix.h"
#include "node.h"
#include "material.h"
#include "face.h"

class C3D4 {
private:
    std::vector<const node*> nodes;
    material_type material;
    double V = 0.0;
    double detJ = 0.0;

    dmatrix<double> Be();
    dmatrix<double> De();
    dmatrix<double> Ke();
    void calc_detJ();
    void calc_V();

    [[nodiscard]] double x(int n) const;
    [[nodiscard]] double y(int n) const;
    [[nodiscard]] double z(int n) const;

public:
    C3D4(const std::vector<const node*>& Nodes, material_type mat);

    void calc(dmatrix<double>& Kele, std::vector<double>& node_mass);

    [[nodiscard]] std::vector<int> ldof2gdof() const;
    [[nodiscard]] std::vector<face> getfaces() const;
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\face.h
#pragma once
#include <vector>
#include <memory>  // If smart pointers are needed
#include "dmatrix.h"
#include "node.h"

// Face definition
class face
{
private:
    [[nodiscard]] double triarea(int n1, int n2, int n3) const;

public:
    std::vector<std::shared_ptr<node>> nodes;  // Use smart pointers for ownership management

    void push_back(const std::shared_ptr<node>& n) { nodes.emplace_back(n); }

    bool operator<(const face& f) const;

    [[nodiscard]] double area() const;
    [[nodiscard]] point normal() const;
    [[nodiscard]] point centroid() const;
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\fem.h
#pragma once
#include <vector>
#include <map>
#include <set>
#include <string>
#include <memory>
#include "mkl.h"
#include <gmm/gmm.h>

#include "femoptions.h"
#include "node.h"
#include "element.h"
#include "elementset.h"
#include "nodeset.h"
#include "face.h"

class fem
{
public:
	using loadmap_t = std::map<size_t, point>;

	enum class im_direction_t
	{
		NORMAL,
		ANTI_NORMAL
	};

public:
	std::vector<node> nodes;
	size_t nodecnt = 0;

	int udof = 0; // Number of unconstrained DOF

	std::vector<element> elements;
	size_t elementcnt = 0;

	std::map<std::string, nodeset> nodesets;
	std::map<std::string, elementset> elementsets;

	// Stiffness matrix
	gmm::row_matrix<gmm::wsvector<double>> K_gmm;
	gmm::csc_matrix<double>	K_gmm_csc;

	// Node mass matrix (lumped form, so a diagonal vector)
	std::vector<double> nodes_mass;

	std::map<face, size_t> externalelementfaces;

	// The gap set
	nodeset* gap_nodeset = nullptr;

	// Faces that make up the gap set, used for searching
	std::set<const face*> gap_face_set;
	std::vector<const face*> gap_face_vector;
	std::vector<point> gap_node_norms;

	// Used for IR
	struct
	{
		double body_mass = 0.0;
		point cog;
		double scale = 1.0;
	} IR;

	im_direction_t im_direction = im_direction_t::NORMAL;

	// Intel MKL
	struct mkl_t
	{
		void* pt[64]{};
		_INTEGER_t maxfct = 0;
		_INTEGER_t mnum = 0;
		_INTEGER_t mtype = 0;
		_INTEGER_t phase = 0;

		_INTEGER_t iparm[64]{};
		_INTEGER_t msglvl = 0;
		_INTEGER_t error = 0;

		_INTEGER_t n = 0;

		std::unique_ptr<double[]> K_csr;
		std::unique_ptr<_INTEGER_t[]> ia;
		std::unique_ptr<_INTEGER_t[]> ja;
		std::unique_ptr<_INTEGER_t[]> perm; // Not used

		mkl_t() = default;

		~mkl_t() = default; // Smart pointers automatically deallocate
	} mkl;

	// Helper methods
	std::vector<const node*> nid2node(const std::vector<size_t>& nids);
	static std::vector<double> inverse_3x3(const std::vector<double>& A);

public:
	// FEM options
	femoptions options;

	// Member methods - IO
	void readoptions(const std::string& file);
	void loadinp();
	void writeVTK(const std::string& filename, const std::vector<double>& b, const std::vector<double>& x);
	void writeFacesetVTK(const std::string& filename, const std::vector<const face*>& fs);
	void getim(std::vector<double>::iterator x, std::vector<double>& im);

	// Member methods - loading
	void setupgap(const std::string& gap_set_name, im_direction_t direction);
	void nodeset2faceset(const nodeset& ns, std::vector<const face*>& fs);
	void load_gap_face(size_t faceid, double pressure, loadmap_t& loadmap);
	void load_set(const std::string& setname, double pressure, loadmap_t& loadmap);

	void loadmap2b(const loadmap_t& loadmap, std::vector<double>::iterator b);
	void loadmap2b(const loadmap_t& loadmap, std::vector<double>& b);

	// Member methods - helping
	void number_DOF();
	void stiffness_matrix(bool only_triu = false);
	size_t get_gap_facecnt() const;
	size_t get_gap_nodecnt() const;
	int get_udof() const;

	// Solving - GMM
	void gmm_setup();
	bool gmm_solve(const loadmap_t& loadmap, std::vector<double>& b, std::vector<double>& x);

	// Solving - MKL
	void K_gmm2K_csr(bool only_triu = true);
	void mkl_phase0();
	void mkl_phase11();
	void mkl_phase22();
	void mkl_phase33(_INTEGER_t nrhs, double* b, double* x);
	void mkl_gap_ims(int startid, _INTEGER_t nrhs, std::vector<double>& b, std::vector<double>& x);
	void mkl_solve(const loadmap_t& loadmap, std::vector<double>& b, std::vector<double>& x);
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\femoptions.h
#pragma once
#include <string>
#include <vector>
#include <map>

#include "material.h"

struct femoptions
{
    struct elastic_constraint
    {
        int x = 0;
        int y = 0;
        int z = 0;
    };

    // General options
    std::string pump_name;
    std::string meshfile;
    double scalefactor = 1e-3; // Default scale factor

    // Activate Inertial Relief
    int inrel = 0;

    // Specify the RAM amount for Pardiso solver
    int max_ram = 2000;

    // The list of materials / elastic constraints
    std::vector<material_type> materials;
    std::map<std::string, size_t> elementset_material;
    std::map<std::string, elastic_constraint> elastic_constraints;

    // Default constructor
    femoptions() = default;

    // Clear method - properly resets values
    void clear()
    {
        *this = femoptions(); // Reset to default-initialized object
    }
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\influgen.h
#pragma once
#include <string>
#include <unordered_map>
#include "fem.h"

class influGen
{
public:
    enum class part_type
    {
        PISTON,
        BUSHING,
        BLOCK,
        VALVEPLATE,
        SLIPPER,
        SWASHPLATE,
        NONE
    };

    enum class solver_type
    {
        GMM,
        PARDISO
    };

    part_type part;
    const solver_type solver;
    fem model;

private:
    // These functions generate the correct file path for each interface
    std::string filename_gap(size_t id, bool is_vtk = false);
    std::string filename_gapim();
    std::string filename_set(std::string_view setname, bool is_vtk = false);

public:
    influGen(part_type Part, solver_type Solver);
    void load(std::string_view optionfile);
    void stiffness();
    void setup(std::string_view gap_set_name);

    void make_SlipperSwash_mesh_files();
    void make_PistonBush_mesh_files();
    void make_BlockVP_mesh_files();

    void make_vizvtksets();

    void cleanup();
    void gmm_gap_im(size_t id, bool writevtk = false);
    void gmm_set_im(std::string_view setname, bool writevtk = false);
    void mkl_gap_ims();
    void mkl_set_im(std::string_view setname, bool writevtk);
    void mkl_gap_im(size_t id, bool writevtk = false);
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\material.h
#pragma once
#include <string_view>

struct material_type
{
    std::string_view name;
    double E;
    double nu;
    double rho;
};

File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\node.h
#pragma once
#include <array>
#include "point.h"

struct node
{
	// The node ID in the global node vector
	size_t nid = 0;

	// XYZ location
	point coord{ 0.0, 0.0, 0.0 };

	// Global DOF numbering (assume 3 DOF per node)
	std::array<int, 3> DOF{};

	// Default constructor
	node() = default;

	// Constructor with a point object
	explicit node(const point& p) : coord(p) {}

	// Constructor with individual x, y, z values
	node(double x, double y, double z) : coord{ x, y, z } {}

	// Access coordinate components
	[[nodiscard]] constexpr double operator[](int i) const noexcept
	{
		return coord[i];
	}

	[[nodiscard]] constexpr double x() const noexcept
	{
		return coord.x();
	}

	[[nodiscard]] constexpr double y() const noexcept
	{
		return coord.y();
	}

	[[nodiscard]] constexpr double z() const noexcept
	{
		return coord.z();
	}
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\nodeset.h
#pragma once
#include <vector>

// Using a vector instead of a set to maintain read order
// in case the read order is not ascending
class nodeset : public std::vector<size_t>
{
public:
    bool const_x = false;
    bool const_y = false;
    bool const_z = false;

    nodeset() = default; // Default constructor
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\point.h
#pragma once

#include <array>
#include <cmath>
#include <iostream>

struct point {
    std::array<double, 3> coord{};

    // Constructors
    constexpr point(double x, double y, double z) noexcept : coord{ x, y, z } {}
    constexpr point(std::array<double, 3> arr) noexcept : coord{ arr } {}
    constexpr point() noexcept = default;

    // Access operators
    double& operator[](int i) noexcept { return coord[i]; }
    [[nodiscard]] constexpr double operator[](int i) const noexcept { return coord[i]; }

    [[nodiscard]] constexpr double x() const noexcept { return coord[0]; }
    [[nodiscard]] constexpr double y() const noexcept { return coord[1]; }
    [[nodiscard]] constexpr double z() const noexcept { return coord[2]; }

    // Arithmetic operators
    [[nodiscard]] constexpr point operator+(const point& p) const noexcept {
        return { coord[0] + p.coord[0], coord[1] + p.coord[1], coord[2] + p.coord[2] };
    }

    [[nodiscard]] constexpr point operator-(const point& p) const noexcept {
        return { coord[0] - p.coord[0], coord[1] - p.coord[1], coord[2] - p.coord[2] };
    }

    [[nodiscard]] constexpr point operator*(double d) const noexcept {
        return { coord[0] * d, coord[1] * d, coord[2] * d };
    }

    [[nodiscard]] constexpr point operator/(double d) const noexcept {
        return { coord[0] / d, coord[1] / d, coord[2] / d };
    }

    point& operator+=(const point& p) noexcept {
        for (int i = 0; i < 3; i++) coord[i] += p.coord[i];
        return *this;
    }

    point& operator-=(const point& p) noexcept {
        for (int i = 0; i < 3; i++) coord[i] -= p.coord[i];
        return *this;
    }

    point& operator*=(double s) noexcept {
        for (double& c : coord) c *= s;
        return *this;
    }

    point& operator/=(double s) noexcept {
        for (double& c : coord) c /= s;
        return *this;
    }

    // Norm (Magnitude)
    [[nodiscard]] double norm() const noexcept {
        return std::sqrt(coord[0] * coord[0] + coord[1] * coord[1] + coord[2] * coord[2]);
    }

    // Normalized Vector
    [[nodiscard]] point normalized() const noexcept {
        double magnitude = norm();
        return (magnitude > 0) ? (*this / magnitude) : point(0, 0, 0);
    }

    // Dot Product
    [[nodiscard]] constexpr double dot(const point& p) const noexcept {
        return coord[0] * p.coord[0] + coord[1] * p.coord[1] + coord[2] * p.coord[2];
    }

    // Cross Product
    [[nodiscard]] static constexpr point cross(const point& p1, const point& p2) noexcept {
        return {
            p1.coord[1] * p2.coord[2] - p1.coord[2] * p2.coord[1],
            p1.coord[2] * p2.coord[0] - p1.coord[0] * p2.coord[2],
            p1.coord[0] * p2.coord[1] - p1.coord[1] * p2.coord[0]
        };
    }

    // Comparison Operators
    [[nodiscard]] constexpr bool operator==(const point& p) const noexcept {
        return coord[0] == p.coord[0] && coord[1] == p.coord[1] && coord[2] == p.coord[2];
    }

    [[nodiscard]] constexpr bool operator!=(const point& p) const noexcept {
        return !(*this == p);
    }

    // Unit vectors
    [[nodiscard]] static constexpr point unit_x() noexcept { return { 1, 0, 0 }; }
    [[nodiscard]] static constexpr point unit_y() noexcept { return { 0, 1, 0 }; }
    [[nodiscard]] static constexpr point unit_z() noexcept { return { 0, 0, 1 }; }

    // Stream output operator
    friend std::ostream& operator<<(std::ostream& os, const point& p) {
        return os << "(" << p.coord[0] << ", " << p.coord[1] << ", " << p.coord[2] << ")";
    }
};


File: E:/Job_1/Influgen_3/Influgen_3/ConsoleApplication1/src/include\string_functions.h
#pragma once
#include <string>
#include <sstream>
#include <vector>
#include <string_view>
#include <algorithm>
using namespace std;
namespace string_functions
{
    std::vector<std::string> Tokenize(std::string_view str, std::string_view delimiters);
    double s2d(std::string_view s);
    int s2i(std::string_view s);
    std::string str2lower(std::string s);
    std::string trim(std::string s);

    template <typename T>
    std::string n2s(T number)
    {
        return std::to_string(number);
    }
}


